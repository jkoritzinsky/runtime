// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Interop.Generators;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Microsoft.Interop
{
    [Generator]
    public class StructMarshallingGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var structMarshallingContextProvider =
                context.SyntaxProvider.CreateSyntaxProvider(ShouldVisitNode, (context, ct) => (Syntax: (StructDeclarationSyntax)context.Node, Symbol: (INamedTypeSymbol)context.SemanticModel.GetDeclaredSymbol(context.Node, ct)))
                    .Where(syntaxAndSymbol => HasTriggerAttribute(syntaxAndSymbol.Symbol))
                    .Combine(context.CompilationProvider)
                    .Combine(context.CreateStructMarshallingFeatureCacheProvider())
                    .Select((data, ct) => (data.Left.Left.Syntax, Context: CreateStructMarshallingContext(data.Left.Left.Symbol, data.Left.Right, data.Right)));

            context.RegisterSourceOutput(
                    structMarshallingContextProvider
                    .Where(data => !data.Context.MarshallingFeatures.IsBlittable)
                    .Select((syntaxAndContext, ct) => GenerateSyntaxAndDiagnosticsFromContext(syntaxAndContext.Syntax, syntaxAndContext.Context))
                    .Select((syntaxAndDiagnostics, ct) => (syntaxAndDiagnostics.Syntax.NormalizeWhitespace().ToFullString(), syntaxAndDiagnostics.Diagnostics))
                    .Collect()
                    .Select((generatedSources, ct) =>
                    {
                        StringBuilder source = new();
                        // Mark in source that the file is auto-generated.
                        source.AppendLine("// <auto-generated/>");
                        ImmutableArray<Diagnostic>.Builder diagnostics = ImmutableArray.CreateBuilder<Diagnostic>();
                        foreach ((string, ImmutableArray<Diagnostic>) generated in generatedSources)
                        {
                            source.AppendLine(generated.Item1);
                            diagnostics.AddRange(generated.Item2);
                        }
                        return (source: source.ToString(), diagnostics: diagnostics.ToImmutable());
                    }),
                (context, data) =>
                {
                    foreach (Diagnostic diagnostic in data.diagnostics)
                    {
                        context.ReportDiagnostic(diagnostic);
                    }

                    context.AddSource("GeneratedStructMarshalling.NonBlittable.g.cs", data.source);
                });
        }

        private (MemberDeclarationSyntax Syntax, ImmutableArray<Diagnostic> Diagnostics) GenerateSyntaxAndDiagnosticsFromContext(StructDeclarationSyntax originalSyntax, StructMarshallingContext context)
        {
            IMarshallingGeneratorFactory generatorFactory = new MarshalAsMarshallingGeneratorFactory(
                 new InteropGenerationOptions(false, false),
                 new UnsupportedMarshallingFactory());
            // Don't validate scenario support here as we will propogate up the same limitations in our generated source.
            FixedBufferMarshallingGeneratorFactory fixedBufferMarshallerGeneratorFactory = new(generatorFactory)
            {
                ElementMarshallingGeneratorFactory = new AttributedMarshallingModelGeneratorFactory(generatorFactory, new AttributedMarshallingModelGeneratorFactoryOptions(false, false, RuntimeMarshallingDisabled: true))
            };

            GeneratorDiagnostics diagnostics = new();

            StructDeclarationSyntax nativeMarshallingStruct = StructMarshallingImplementationGenerator.GenerateStructMarshallingCode(
                context,
                (info, ex) => diagnostics.ReportMarshallingNotSupported(originalSyntax, info.InstanceIdentifier, ex.NotSupportedDetails),
                fixedBufferMarshallerGeneratorFactory);

            return (PrintGeneratedSource(context.Namespace, originalSyntax, nativeMarshallingStruct), context.Diagnostics.AddRange(diagnostics.ToImmutable()));
        }

        private static MemberDeclarationSyntax PrintGeneratedSource(
            string? @namespace,
            StructDeclarationSyntax originalSyntax,
            StructDeclarationSyntax nativeMarshallingStruct)
        {
            // Create stub function
            MemberDeclarationSyntax rootDeclaration = nativeMarshallingStruct;

            bool addNativeMarshallingAttribute = true;
            foreach (TypeDeclarationSyntax containingType in originalSyntax.AncestorsAndSelf().OfType<TypeDeclarationSyntax>())
            {
                rootDeclaration = CreateTypeDeclarationWithoutTrivia(containingType).AddMembers(rootDeclaration);
                if (addNativeMarshallingAttribute)
                {
                    // Add the NativeMarshallingAttribute to the user-declared struct
                    rootDeclaration = rootDeclaration.AddAttributeLists(
                        AttributeList(
                            SingletonSeparatedList(
                                Attribute(
                                    IdentifierName(TypeNames.NativeMarshallingAttribute),
                                    AttributeArgumentList(
                                        SingletonSeparatedList(AttributeArgument(TypeOfExpression(IdentifierName("__Native")))))))));
                    addNativeMarshallingAttribute = false;
                }
            }

            // Add type to the containing namespace
            if (!string.IsNullOrEmpty(@namespace))
            {
                return NamespaceDeclaration(IdentifierName(@namespace))
                    .AddMembers(rootDeclaration);
            }

            return rootDeclaration;
        }

        private static TypeDeclarationSyntax CreateTypeDeclarationWithoutTrivia(TypeDeclarationSyntax typeDeclaration)
        {
            return TypeDeclaration(
                typeDeclaration.Kind(),
                typeDeclaration.Identifier)
                .WithTypeParameterList(typeDeclaration.TypeParameterList)
                .WithModifiers(typeDeclaration.Modifiers);
        }

        private static StructMarshallingContext CreateStructMarshallingContext(INamedTypeSymbol symbol, Compilation compilation, StructMarshallingFeatureCache generatedStructMarshallingCache)
        {
            return StructMarshallingContext.Create(symbol, compilation, generatedStructMarshallingCache);
        }

        private static bool HasTriggerAttribute(INamedTypeSymbol symbol)
            => symbol.GetAttributes().Any(static attribute => attribute.AttributeClass?.ToDisplayString() == TypeNames.GeneratedMarshallingAttribute);

        private static bool ShouldVisitNode(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            // We only support C# declarations.
            if (syntaxNode.Language != LanguageNames.CSharp
                || !(syntaxNode.IsKind(SyntaxKind.StructDeclaration) || syntaxNode.IsKind(SyntaxKind.RecordStructDeclaration)))
            {
                return false;
            }

            var declSyntax = (StructDeclarationSyntax)syntaxNode;

            // Verify the type is not generic and is partial
            if (declSyntax.TypeParameterList is not null
                || !declSyntax.Modifiers.Any(SyntaxKind.PartialKeyword))
            {
                return false;
            }

            // Verify that the types the type is declared in are marked partial.
            for (SyntaxNode? parentNode = declSyntax.Parent; parentNode is TypeDeclarationSyntax typeDecl; parentNode = parentNode.Parent)
            {
                if (!typeDecl.Modifiers.Any(SyntaxKind.PartialKeyword))
                {
                    return false;
                }
            }

            // Filter out types with no attributes early.
            if (declSyntax.AttributeLists.Count == 0)
            {
                return false;
            }

            return true;
        }
    }
}
